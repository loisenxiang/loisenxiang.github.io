<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>block详解 | 孙翔的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="分两部分内容来剖析block：

怎么用
为什么这么用

block用法分类：
根据Block在内存中的位置分为三种类型NSGlobalBlock，NSStackBlock, NSMallocBlock。
NSGlobalBlock：类似函数，位于text段； NSStackBlock：位于栈内存，函数返回后Block将无效； NSMallocBlock：位于堆内存。需要开发者进行释放。区分：非A">
<meta property="og:type" content="article">
<meta property="og:title" content="block详解">
<meta property="og:url" content="http://yoursite.com/2016/04/18/Block/index.html">
<meta property="og:site_name" content="孙翔的技术博客">
<meta property="og:description" content="分两部分内容来剖析block：

怎么用
为什么这么用

block用法分类：
根据Block在内存中的位置分为三种类型NSGlobalBlock，NSStackBlock, NSMallocBlock。
NSGlobalBlock：类似函数，位于text段； NSStackBlock：位于栈内存，函数返回后Block将无效； NSMallocBlock：位于堆内存。需要开发者进行释放。区分：非A">
<meta property="og:updated_time" content="2016-04-28T04:06:13.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="block详解">
<meta name="twitter:description" content="分两部分内容来剖析block：

怎么用
为什么这么用

block用法分类：
根据Block在内存中的位置分为三种类型NSGlobalBlock，NSStackBlock, NSMallocBlock。
NSGlobalBlock：类似函数，位于text段； NSStackBlock：位于栈内存，函数返回后Block将无效； NSMallocBlock：位于堆内存。需要开发者进行释放。区分：非A">
  
    <link rel="alternate" href="/atom.xml" title="孙翔的技术博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">孙翔的技术博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">积累学到的点点滴滴</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Block" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/18/Block/" class="article-date">
  <time datetime="2016-04-18T15:46:43.000Z" itemprop="datePublished">2016-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      block详解
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>分两部分内容来剖析block：</p>
<ol>
<li>怎么用</li>
<li>为什么这么用</li>
</ol>
<h2 id="block用法"><a href="#block用法" class="headerlink" title="block用法"></a>block用法</h2><p>分类：</p>
<p>根据Block在内存中的位置分为三种类型NSGlobalBlock，NSStackBlock, NSMallocBlock。</p>
<p>NSGlobalBlock：类似函数，位于text段； NSStackBlock：位于栈内存，函数返回后Block将无效； NSMallocBlock：位于堆内存。需要开发者进行释放。<br>区分：非ARC下，无引用外部变量的即为NSGlobalBlock，引用外部变量的为NSStackBlock，NSStakBlock做copy即为NSMallocBlock。<br>内存管理：</p>
<p>block是编译时生成的，而不是运行时生成的。所以在编译时如果用到外部变量就会把变量建一份快照放到栈上。</p>
<ul>
<li>NSGlobalBlock：生命周期从应用程序开始到程序终止。对其做retain/release/copy都没有任何意义，还是返回本身。</li>
<li>NSStackBlock：函数返回后即消失。对其做retain/release都没有任何意义，还是返回本身。对其做copy则会把内容复制到堆内存(NSMallocBlock)，生成新的内存块。</li>
<li>NSMallocBlock：需要程序员自己释放，对其做retain和copy一样，只是所指对象计数器增加1，打印时一直会显示1，但实际计数器已经增加了。对其做release计数器减一，不过打印计数器时，一直还是显示1。</li>
</ul>
<pre><code>typedef int (^square)(int);
- (void) viewDidLoad
{
    [super viewDidLoad];

    square tempBlock1 = ^(int a){ return a * a; };

    NSLog(@"tempBlock1:%@, return1:%d", tempBlock1, tempBlock1(5));
    // log: tempBlock1:<__nsglobalblock__: 0x10e6d9240="">, return1:25

    int i = 2;
    square temptBlock2 = ^(int a){ int itRet = i * a; return itRet; };
    NSLog(@"temptBlock2:%@, return2:%d", temptBlock2, temptBlock2(5));
    // log: temptBlock2:<__nsstackblock__: 0x7fff51528a50="">, return2:10

    square temptBlock3 = [temptBlock2 copy];
    NSLog(@"temptBlock3:%@, return3:%d", temptBlock3, temptBlock3(5));
    // log: temptBlock3:<__nsmallocblock__: 0x7fbdc0608180="">, return3:10

    temptBlock = [temptBlock3 copy];
    NSLog(@"temptBlock:%@, return:%d", temptBlock, temptBlock(5));
    // log: temptBlock:<__nsmallocblock__: 0x7fbdc0608180="">, return3:10  此时temptBlock的计数器实际上是2

    [temptBlock release];
 }

- (IBAction)Test:(id)sender {
    NSLog(@"=====temptBlock:%@, return:%d, blockRec:%ld", temptBlock, temptBlock(5), [temptBlock retainCount]);

    // 如果viewDidLoad中temptBlock再做次release就crash了 这里
}
</__nsmallocblock__:></__nsmallocblock__:></__nsstackblock__:></__nsglobalblock__:></code></pre>


<h2 id="修改变量值原理"><a href="#修改变量值原理" class="headerlink" title="修改变量值原理"></a>修改变量值原理</h2><pre><code>typedef int (^square)(int);

int i = 6;
square tempBlock1 = ^(int a){return a * i; };

printf("=====%d", tempBlock1(5));</code></pre>

<p>如果想在tempBlock1中更改i值是不被允许的，为什么？查看代码的底层实现:clang -rewrite-objc block2.c，去掉不必要的代码，保留主要代码：</p>
<pre><code>struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};


struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  int i;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _i, int flags=0) : i(_i) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};


static int __main_block_func_0(struct __main_block_impl_0 *__cself, int a) {
  int i = __cself->i; // bound by copy
return a * i; }


static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};


int main()
{
    int i = 6;
    square tempBlock1 = ((int (*)(int))&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, i));

    printf("=====%d", ((int (*)(__block_impl *, int))((__block_impl *)tempBlock1)->FuncPtr)((__block_impl *)tempBlock1, 5));

    return 0;
}</code></pre>

<p>代码看上去有些多，看主要信息：</p>
<ol>
<li><strong>block_impl：isa指名是一个对象，指向所属类的指针也就是保存了block的类型（这里为栈对象），flags记录block的标识，reserved：保留字段为了扩展，funcptr：block执行的函数体，也就是block的实现。</strong>main_block_impl_0：包含<strong>block_impl对象和</strong>main_block_desc_0（就是记录<strong>main_block_impl_0的大小），以及外部变量的映像。个人理解其实</strong>block_impl就是__main_block_impl_0的基类。</li>
<li>顺序：创建tempBlock1对象，执行block的函数体。</li>
<li>为什么不能在block中直接更改变量值，因为传的只是形参，如果改变的话只能操作tempBlock1中的i的改变，但是外部的变量i是不会被改变的，所以干脆禁止这么操作。那么怎么改才能和外部的联动？</li>
</ol>
<pre><code>{
    __block int i = 6;
    square tempBlock1 = ^(int a){ i = i + 1; return a * i; };

    i = 7;

    printf("=====%d,i=%d", tempBlock1(5), i);

    return 0;
}</code></pre>

<p>同样查看源码，去掉不必要的代码：</p>
<pre><code>struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};


struct __Block_byref_i_0 {
  void *__isa;
__Block_byref_i_0 *__forwarding;
 int __flags;
 int __size;
 int i;
};


struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __Block_byref_i_0 *i; // by ref
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i->__forwarding) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};


static int __main_block_func_0(struct __main_block_impl_0 *__cself, int a) {
  __Block_byref_i_0 *i = __cself->i; // bound by ref
 (i->__forwarding->i) = (i->__forwarding->i) + 1; return a * (i->__forwarding->i); }


static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&dst->i, (void*)src->i, 8/*BLOCK_FIELD_IS_BYREF*/);}


static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src->i, 8/*BLOCK_FIELD_IS_BYREF*/);}


static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};


int main()
{
    __attribute__((__blocks__(byref))) __Block_byref_i_0 i = {(void*)0,(__Block_byref_i_0 *)&i, 0, sizeof(__Block_byref_i_0), 6};
    square tempBlock1 = ((int (*)(int))&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, (__Block_byref_i_0 *)&i, 570425344));

    (i.__forwarding->i) = 7;

    printf("=====%d,i=%d", ((int (*)(__block_impl *, int))((__block_impl *)tempBlock1)->FuncPtr)((__block_impl *)tempBlock1, 5), (i.__forwarding->i));

    return 0;
}</code></pre>


<p>只看不同的代码：</p>
<ol>
<li>多了个<strong>Block_byref_i_0：生成</strong>Block_byref_i_0对象i存储外部变量的值，这样把<strong>Block_byref_i_0对象i的指针传入block中，在栈函数funptr中直接改变</strong>Block_byref_i_0对象i中int变量i的值，因为block外部和内部都用的是同一个对象指针，所以在block内外改变其中的值是联动的即同一份。</li>
<li>多了个<strong>main_block_copy_0：如果block从栈中复制到堆中时，会调用此函数，里面的实现就是把</strong>Block_byref_i_0对象i栈的i-&gt;forwarding指向__Block_byref_i_0堆中的地址。这样堆中操作了，栈中也会联动改变。也是forwarding的作用（代码实现在下面）。</li>
<li>__main_block_dispose_0：在block释放时会调用此函数。</li>
</ol>
<p>具体源码查看苹果blockRuntime里面的这些实现的源码，<a href="http://opensource.apple.com/source/clang/clang-137/src/projects/compiler-rt/BlocksRuntime/runtime.c" target="_blank" rel="external">网址点击这里</a>:</p>
<pre><code>
void _Block_object_assign(void *destAddr, const void *object, const int flags)
{
    //printf("_Block_object_assign(*%p, %p, %x)\n", destAddr, object, flags);
    if ((flags & BLOCK_BYREF_CALLER) == BLOCK_BYREF_CALLER)
    {
        if ((flags & BLOCK_FIELD_IS_WEAK) == BLOCK_FIELD_IS_WEAK)
        {
            _Block_assign_weak(object, destAddr);
        }
        else
        {
            // do *not* retain or *copy* __block variables whatever they are
            _Block_assign((void *)object, destAddr);
        }
    }
    else if ((flags & BLOCK_FIELD_IS_BYREF) == BLOCK_FIELD_IS_BYREF)
    {
        // copying a __block reference from the stack Block to the heap
        // flags will indicate if it holds a __weak reference and needs a special isa
        _Block_byref_assign_copy(destAddr, object, flags);
    }
    // (this test must be before next one)
    else if ((flags & BLOCK_FIELD_IS_BLOCK) == BLOCK_FIELD_IS_BLOCK)
    {
        // copying a Block declared variable from the stack Block to the heap
        _Block_assign(_Block_copy_internal(object, flags), destAddr);
    }
    // (this test must be after previous one)
    else if ((flags & BLOCK_FIELD_IS_OBJECT) == BLOCK_FIELD_IS_OBJECT)
    {
        //printf("retaining object at %p\n", object);
        _Block_retain_object(object);
        //printf("done retaining object at %p\n", object);
        _Block_assign((void *)object, destAddr);
    }
}


static void _Block_byref_assign_copy(void *dest, const void *arg, const int flags)
{
    struct Block_byref **destp = (struct Block_byref **)dest;
    struct Block_byref *src = (struct Block_byref *)arg;
    if (src->forwarding->flags & BLOCK_IS_GC)
    {
        ;   // don't need to do any more work
    }
    else if ((src->forwarding->flags & BLOCK_REFCOUNT_MASK) == 0)
    {
        //printf("making copy\n");
        // src points to stack
        bool isWeak = ((flags & (BLOCK_FIELD_IS_BYREF|BLOCK_FIELD_IS_WEAK)) == (BLOCK_FIELD_IS_BYREF|BLOCK_FIELD_IS_WEAK));
        // if its weak ask for an object (only matters under GC)
        struct Block_byref *copy = (struct Block_byref *)_Block_allocator(src->size, false, isWeak);
        copy->flags = src->flags | _Byref_flag_initial_value; // non-GC one for caller, one for stack
        copy->forwarding = copy; // patch heap copy to point to itself (skip write-barrier)
        src->forwarding = copy;  // patch stack to point to heap copy
        copy->size = src->size;
        if (isWeak) {
            copy->isa = &_NSConcreteWeakBlockVariable;  // mark isa field so it gets weak scanning
        }
        if (src->flags & BLOCK_HAS_COPY_DISPOSE) {
            // Trust copy helper to copy everything of interest
            // If more than one field shows up in a byref block this is wrong XXX
            copy->byref_keep = src->byref_keep;
            copy->byref_destroy = src->byref_destroy;
            (*src->byref_keep)(copy, src);
        }
        else {
            // just bits.  Blast 'em using _Block_memmove in case they're __strong
            _Block_memmove(
                           (void *)&copy->byref_keep,
                           (void *)&src->byref_keep,
                           src->size - sizeof(struct Block_byref_header));
        }
    }
    // already copied to heap
    else if ((src->forwarding->flags & BLOCK_NEEDS_FREE) == BLOCK_NEEDS_FREE) {
        latching_incr_int(&src->forwarding->flags);
    }
    // assign byref data block pointer into new Block
    _Block_assign(src->forwarding, (void **)destp);
}
</code></pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/18/Block/" data-id="cinepjpr00000plzxpuv7h7dy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/block/">block</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/04/24/copy/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          copy与mutableCopy的内存管理剖析
        
      </div>
    </a>
  
  
    <a href="/2016/04/18/TextAndImage/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">文字和图片混排</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/NSMutableAttributedString/">NSMutableAttributedString</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/block/">block</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/copy/">copy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/堆栈/">堆栈</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/NSMutableAttributedString/" style="font-size: 10px;">NSMutableAttributedString</a> <a href="/tags/block/" style="font-size: 10px;">block</a> <a href="/tags/copy/" style="font-size: 10px;">copy</a> <a href="/tags/堆栈/" style="font-size: 10px;">堆栈</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/04/24/copy/">copy与mutableCopy的内存管理剖析</a>
          </li>
        
          <li>
            <a href="/2016/04/18/Block/">block详解</a>
          </li>
        
          <li>
            <a href="/2016/04/18/TextAndImage/">文字和图片混排</a>
          </li>
        
          <li>
            <a href="/2016/04/18/HeapAndStack/">深度剖析堆栈</a>
          </li>
        
          <li>
            <a href="/2016/04/18/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Xiang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>