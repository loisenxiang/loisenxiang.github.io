<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>孙翔的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="孙翔的技术博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="孙翔的技术博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="孙翔的技术博客">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="孙翔的技术博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">孙翔的技术博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">积累学到的点点滴滴</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-copy" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/24/copy/" class="article-date">
  <time datetime="2016-04-24T08:50:04.000Z" itemprop="datePublished">2016-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/24/copy/">copy与mutableCopy的内存管理剖析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="copy与mutableCopy相关的内存管理"><a href="#copy与mutableCopy相关的内存管理" class="headerlink" title="copy与mutableCopy相关的内存管理"></a>copy与mutableCopy相关的内存管理</h2><p>不知道为什么一说这个，很多人都拿NSString和NSMutableString做测试，我想最直接的是因为常用又实现了copy和mutableCopy的代理，但是NSString类的其实比较特殊，不应该拿NSString来测试，所以本文拿实现代理的NSURLRequest来做测试。</p>
<h4 id="immutableObject："><a href="#immutableObject：" class="headerlink" title="immutableObject："></a>immutableObject：</h4><h5 id="非集合的"><a href="#非集合的" class="headerlink" title="非集合的"></a>非集合的</h5><pre><code>NSURL *url = [[NSURL alloc] initWithString:@"ceshi"];
NSURLRequest *urlRequest = [[NSURLRequest alloc] initWithURL:url];
NSLog(@"urlReqeust:%@, urlRequestRec:%ld", urlRequest, [urlRequest retainCount]);  
//log: urlReqeust:<nsurlrequest: 0x7fb763f11090=""> { URL: ceshi }, urlRequestRec:1

NSURLRequest *urlRequest1 = [urlRequest copy];
NSLog(@"urlRequest1:%@, urlRequest1:%ld", urlRequest1, [urlRequest1 retainCount]);
// log: urlRequest1:<nsurlrequest: 0x7fb763f11090=""> { URL: ceshi }, urlRequest1:2</nsurlrequest:></nsurlrequest:></code></pre>

<p>总结：immutableObject做copy时，做的是浅copy，也就是说只是所指向的对象的内存计数器增加了1，所以如果urlRequest1重新赋值时，需要做下release把之前所指的对象的内存计数器减1，否则就会有内存泄露。如下：</p>
<pre><code>[urlRequest1 release], urlRequest1 = nil;
// 此时urlRequest所指对象计数器为1，urlRequest1为nil
urlRequest1 = [NSURLRequest requestWithURL:[NSURL URLWithString:@"ceshi2"]];
// 此时urlRequest1指向新的对象，指向的对象的计数器为1</code></pre>

<h5 id="集合的"><a href="#集合的" class="headerlink" title="集合的"></a>集合的</h5><pre><code>NSArray *array = @[@[@"a", @"b"], @[@"c", @"d"]];
NSArray *copyArray = [array copy];
NSMutableArray *mCopyArray = [array mutableCopy];
// log: =====array:0x7fb2a8f0d2b0,arrayRec:2, =====copyArray:0x7fb2a8f0d2b0,copyArrayRec:2, ======mCopyArry:0x7fb2a8e10ef0, mCopyArrayRec:1

// 有bug，必须要做copyArray的release    

copyArray = @[@"a",@"d"];
NSLog(@"array:%@,copyArr:%@,mCopyArray:%@", array, copyArray, mCopyArray);
// log: =====array:0x7fb2a8f0d2b0,arrayRec:2, =====copyArray:0x7fb2a8f1b980,copyArrayRec:1, ======mCopyArry:0x7fb2a8e10ef0, mCopyArrayRec:1
</code></pre>

<p>与immutable的非集合一样，copy将直接增加指针指向对象的引用计数器(集合的话：各元素的指针计数器都增加了1)。所以在copyArray更改前，必须要做release，否则会有内存泄漏</p>
<h4 id="mutableObject"><a href="#mutableObject" class="headerlink" title="mutableObject"></a>mutableObject</h4><h5 id="非集合的-1"><a href="#非集合的-1" class="headerlink" title="非集合的"></a>非集合的</h5><pre><code>    NSURL *url = [[NSURL alloc] initWithString:@"ceshi"];
    NSURLRequest *urlRequest = [[NSURLRequest alloc] initWithURL:url];
    NSLog(@"urlReqeust:%@, urlRequestRec:%ld\r", urlRequest, [urlRequest retainCount]);
    // log: urlReqeust:<nsurlrequest: 0x7f98dac07e00=""> { URL: ceshi }, urlRequestRec:1

    NSMutableURLRequest *mutableRequest = [urlRequest mutableCopy];
    NSLog(@"mutableRequest:%@, mutableRequest:%ld", mutableRequest, [mutableRequest retainCount]);
    // log:  mutableRequest:<nsmutableurlrequest: 0x7f98daf07390=""> { URL: ceshi }, mutableRequest:1

    NSMutableURLRequest *mutableRequest1 = [mutableRequest mutableCopy];
    NSLog(@"mutableRequest1:%@, mutableRequest1:%ld", mutableRequest1, [mutableRequest1 retainCount]);
    // log: mutableRequest1:<nsmutableurlrequest: 0x7f98dac674f0=""> { URL: ceshi }, mutableRequest1:1
</nsmutableurlrequest:></nsmutableurlrequest:></nsurlrequest:></code></pre>

<h5 id="集合的-1"><a href="#集合的-1" class="headerlink" title="集合的"></a>集合的</h5><pre><code>
NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@"a"],@"b",@"c",nil];
NSArray *copyArray = [array copy];
NSMutableArray *mCopyArray = [array mutableCopy];
// log: =====array:0x7fbbd3d0d730,arrayRec:1, =====copyArray:0x7fbbd3d19610,copyArrayRec:1, ======mCopyArry:0x7fbbd3d18ad0, mCopyArrayRec:1
</code></pre>

<p>总结：mutableObject的复制是深复制，直接创建一个新的内存地址来复制其内容（在集合中把各个元素的内容都赋值了一遍）。 与之前的被复制项无任何关系。</p>
<p>汇总：</p>
<ul>
<li>[immutableObject copy] // 浅复制</li>
<li>[immutableObject mutableCopy] //深复制</li>
<li>[mutableObject copy] //深复制</li>
<li>[mutableObject mutableCopy] //深复制</li>
</ul>
<h2 id="特殊的NSString"><a href="#特殊的NSString" class="headerlink" title="特殊的NSString"></a>特殊的NSString</h2><pre><code>
NSString *str1 = @"abc";
NSString *str2 = @"abc";
NSString *str3 = [[NSString alloc] initWithString:@"abc"];
NSString *str4 = [str1 copy];
NSString *str5 = [[NSString alloc] initWithString:@"abc"];
NSString *str6 = [str1 mutableCopy];

//输出内存中的地址
NSLog(@"str1: %p", str1);
NSLog(@"str2: %p", str2);
NSLog(@"str3: %p", str3);
NSLog(@"str4: %p", str4);
NSLog(@"str5: %p", str5);
NSLog(@"str6: %p", str6);
</code></pre>

<p>猜下结果：</p>
<p>2016-04-24 22:41:50.629 TestCopy[2094:229125] str1: 0x1081af070<br>2016-04-24 22:41:50.630 TestCopy[2094:229125] str2: 0x1081af070<br>2016-04-24 22:41:50.630 TestCopy[2094:229125] str3: 0x1081af070<br>2016-04-24 22:41:50.630 TestCopy[2094:229125] str4: 0x1081af070<br>2016-04-24 22:41:50.630 TestCopy[2094:229125] str5: 0x1081af070<br>2016-04-24 22:41:50.631 TestCopy[2094:229125] str6: 0x7fb1d3f0ce70</p>
<p>我的理解：<br>NSString在程序中使用非常大，所以在immutable的copy和mutableCopy的原理下，为了系统性能的考虑，增加了只要是NSString存在，则直接把字符串地址付给使用者即可。如果此时str2=@”abdt”了，则直接拿生成的abdt的地址赋值给str2即可。</p>
<h4 id="NSMutableString与immutableObj类似"><a href="#NSMutableString与immutableObj类似" class="headerlink" title="NSMutableString与immutableObj类似"></a>NSMutableString与immutableObj类似</h4><pre><code>
NSMutableString *str1 = [NSMutableString stringWithFormat:@"abc"];
NSMutableString *str2 = [[NSMutableString alloc] initWithString:@"abc"];
NSMutableString *str3 = [str1 copy];
NSMutableString *str4 = [str1 mutableCopy];

//输出内存中的地址
NSLog(@"str1: %p, reC:%ld", str1, [str1 retainCount]);
NSLog(@"str2: %p, reC:%ld", str2, [str2 retainCount]);
NSLog(@"str3: %p", str3);
NSLog(@"str4: %p", str4);
</code></pre>

<p>log:<br>2016-04-24 22:58:42.319 TestCopy[2164:240308] str1: 0x7fa7ebca0c50, reC:1<br>2016-04-24 22:58:42.319 TestCopy[2164:240308] str2: 0x7fa7ebca8560, reC:1<br>2016-04-24 22:58:42.319 TestCopy[2164:240308] str3: 0xa000000006362613<br>2016-04-24 22:58:42.320 TestCopy[2164:240308] str4: 0x7fa7ebca7ed0</p>
<p>最后看2段代码：</p>
<pre><code>
//UserEntity.h
@interface UserEntity : NSObject <nscopying>
@property(strong, nonatomic) NSString *name;
@end
UserEntity *userEntity = [UserEntity new];
//创建mutable类型的字符串
NSMutableString *showName = [[NSMutableString alloc] initWithString:@"tutuge"];
//先保存“tutuge”字符串到userEntity的name
userEntity.name = showName;
//修改showName
[showName appendString:@" blog"];
//输出userEntity的name属性
NSLog(@"Name: %@", userEntity.name);
</nscopying></code></pre>

<p>输出为：tutuge blog </p>
<p>如果更改为：@interface UserEntity : NSObject <nscopying><br>@property(copy, nonatomic) NSString *name;<br>@end</nscopying></p>
<p>则输出为: tutuge</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/24/copy/" data-id="cio5cn3e90004hwzxb0hc12k4" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/copy/">copy</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Block" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/18/Block/" class="article-date">
  <time datetime="2016-04-18T15:46:43.000Z" itemprop="datePublished">2016-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/18/Block/">block深度剖析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>分两部分内容来剖析block：</p>
<ol>
<li>怎么用</li>
<li>为什么这么用</li>
</ol>
<h2 id="block的堆栈"><a href="#block的堆栈" class="headerlink" title="block的堆栈"></a>block的堆栈</h2><p>分类：</p>
<p>根据Block在内存中的位置分为三种类型NSGlobalBlock，NSStackBlock, NSMallocBlock。</p>
<p>NSGlobalBlock：类似函数，位于text段； NSStackBlock：位于栈内存，函数返回后Block将无效； NSMallocBlock：位于堆内存。需要开发者进行释放。<br>区分：非ARC下，无引用外部变量的即为NSGlobalBlock，引用外部变量的为NSStackBlock，NSStakBlock做copy即为NSMallocBlock。<br>内存管理：</p>
<p>block是编译时生成的，而不是运行时生成的。所以在编译时如果用到外部变量就会把变量建一份快照放到栈上。</p>
<ul>
<li>NSGlobalBlock：生命周期从应用程序开始到程序终止。对其做retain/release/copy都没有任何意义，还是返回本身。</li>
<li>NSStackBlock：函数返回后即消失。对其做retain/release都没有任何意义，还是返回本身。对其做copy则会把内容复制到堆内存(NSMallocBlock)，生成新的内存块。</li>
<li>NSMallocBlock：需要程序员自己释放，对其做retain和copy一样，只是所指对象计数器增加1，打印时一直会显示1，但实际计数器已经增加了。对其做release计数器减一，不过打印计数器时，一直还是显示1。</li>
</ul>
<pre><code>typedef int (^square)(int);
- (void) viewDidLoad
{
    [super viewDidLoad];

    square tempBlock1 = ^(int a){ return a * a; };

    NSLog(@"tempBlock1:%@, return1:%d", tempBlock1, tempBlock1(5));
    // log: tempBlock1:<__nsglobalblock__: 0x10e6d9240="">, return1:25

    int i = 2;
    square temptBlock2 = ^(int a){ int itRet = i * a; return itRet; };
    NSLog(@"temptBlock2:%@, return2:%d", temptBlock2, temptBlock2(5));
    // log: temptBlock2:<__nsstackblock__: 0x7fff51528a50="">, return2:10

    square temptBlock3 = [temptBlock2 copy];
    NSLog(@"temptBlock3:%@, return3:%d", temptBlock3, temptBlock3(5));
    // log: temptBlock3:<__nsmallocblock__: 0x7fbdc0608180="">, return3:10

    temptBlock = [temptBlock3 copy];
    NSLog(@"temptBlock:%@, return:%d", temptBlock, temptBlock(5));
    // log: temptBlock:<__nsmallocblock__: 0x7fbdc0608180="">, return3:10  此时temptBlock的计数器实际上是2

    [temptBlock release];
 }

- (IBAction)Test:(id)sender {
    NSLog(@"=====temptBlock:%@, return:%d, blockRec:%ld", temptBlock, temptBlock(5), [temptBlock retainCount]);

    // 如果viewDidLoad中temptBlock再做次release就crash了 这里
}
</__nsmallocblock__:></__nsmallocblock__:></__nsstackblock__:></__nsglobalblock__:></code></pre>


<h2 id="修改变量值原理"><a href="#修改变量值原理" class="headerlink" title="修改变量值原理"></a>修改变量值原理</h2><pre><code>typedef int (^square)(int);

int i = 6;
square tempBlock1 = ^(int a){return a * i; };

printf("=====%d", tempBlock1(5));</code></pre>

<p>如果想在tempBlock1中更改i值是不被允许的，为什么？查看代码的底层实现:clang -rewrite-objc block2.c，去掉不必要的代码，保留主要代码：</p>
<pre><code>struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};


struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  int i;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _i, int flags=0) : i(_i) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};


static int __main_block_func_0(struct __main_block_impl_0 *__cself, int a) {
  int i = __cself->i; // bound by copy
return a * i; }


static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};


int main()
{
    int i = 6;
    square tempBlock1 = ((int (*)(int))&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, i));

    printf("=====%d", ((int (*)(__block_impl *, int))((__block_impl *)tempBlock1)->FuncPtr)((__block_impl *)tempBlock1, 5));

    return 0;
}</code></pre>

<p>代码看上去有些多，看主要信息：</p>
<ol>
<li><strong>block_impl：isa指名是一个对象，指向所属类的指针也就是保存了block的类型（这里为栈对象），flags记录block的标识，reserved：保留字段为了扩展，funcptr：block执行的函数体，也就是block的实现。</strong>main_block_impl_0：包含<strong>block_impl对象和</strong>main_block_desc_0（就是记录<strong>main_block_impl_0的大小），以及外部变量的映像。个人理解其实</strong>block_impl就是__main_block_impl_0的基类。</li>
<li>顺序：创建tempBlock1对象，执行block的函数体。</li>
<li>为什么不能在block中直接更改变量值，因为传的只是形参，如果改变的话只能操作tempBlock1中的i的改变，但是外部的变量i是不会被改变的，所以干脆禁止这么操作。那么怎么改才能和外部的联动？</li>
</ol>
<pre><code>{
    __block int i = 6;
    square tempBlock1 = ^(int a){ i = i + 1; return a * i; };

    i = 7;

    printf("=====%d,i=%d", tempBlock1(5), i);

    return 0;
}</code></pre>

<p>同样查看源码，去掉不必要的代码：</p>
<pre><code>struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};


struct __Block_byref_i_0 {
  void *__isa;
__Block_byref_i_0 *__forwarding;
 int __flags;
 int __size;
 int i;
};


struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __Block_byref_i_0 *i; // by ref
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i->__forwarding) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};


static int __main_block_func_0(struct __main_block_impl_0 *__cself, int a) {
  __Block_byref_i_0 *i = __cself->i; // bound by ref
 (i->__forwarding->i) = (i->__forwarding->i) + 1; return a * (i->__forwarding->i); }


static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&dst->i, (void*)src->i, 8/*BLOCK_FIELD_IS_BYREF*/);}


static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src->i, 8/*BLOCK_FIELD_IS_BYREF*/);}


static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);
  void (*dispose)(struct __main_block_impl_0*);
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};


int main()
{
    __attribute__((__blocks__(byref))) __Block_byref_i_0 i = {(void*)0,(__Block_byref_i_0 *)&i, 0, sizeof(__Block_byref_i_0), 6};
    square tempBlock1 = ((int (*)(int))&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, (__Block_byref_i_0 *)&i, 570425344));

    (i.__forwarding->i) = 7;

    printf("=====%d,i=%d", ((int (*)(__block_impl *, int))((__block_impl *)tempBlock1)->FuncPtr)((__block_impl *)tempBlock1, 5), (i.__forwarding->i));

    return 0;
}</code></pre>


<p>只看不同的代码：</p>
<ol>
<li>多了个<strong>Block_byref_i_0：生成</strong>Block_byref_i_0对象i存储外部变量的值，这样把<strong>Block_byref_i_0对象i的指针传入block中，在栈函数funptr中直接改变</strong>Block_byref_i_0对象i中int变量i的值，因为block外部和内部都用的是同一个对象指针，所以在block内外改变其中的值是联动的即同一份。</li>
<li>多了个<strong>main_block_copy_0：如果block从栈中复制到堆中时，会调用此函数，里面的实现就是把</strong>Block_byref_i_0对象i栈的i-&gt;forwarding指向__Block_byref_i_0堆中的地址。这样堆中操作了，栈中也会联动改变。也是forwarding的作用（代码实现在下面）。</li>
<li>__main_block_dispose_0：在block释放时会调用此函数。</li>
</ol>
<p>具体源码查看苹果blockRuntime里面的这些实现的源码，<a href="http://opensource.apple.com/source/clang/clang-137/src/projects/compiler-rt/BlocksRuntime/runtime.c" target="_blank" rel="external">网址点击这里</a>:</p>
<pre><code>
void _Block_object_assign(void *destAddr, const void *object, const int flags)
{
    //printf("_Block_object_assign(*%p, %p, %x)\n", destAddr, object, flags);
    if ((flags & BLOCK_BYREF_CALLER) == BLOCK_BYREF_CALLER)
    {
        if ((flags & BLOCK_FIELD_IS_WEAK) == BLOCK_FIELD_IS_WEAK)
        {
            _Block_assign_weak(object, destAddr);
        }
        else
        {
            // do *not* retain or *copy* __block variables whatever they are
            _Block_assign((void *)object, destAddr);
        }
    }
    else if ((flags & BLOCK_FIELD_IS_BYREF) == BLOCK_FIELD_IS_BYREF)
    {
        // copying a __block reference from the stack Block to the heap
        // flags will indicate if it holds a __weak reference and needs a special isa
        _Block_byref_assign_copy(destAddr, object, flags);
    }
    // (this test must be before next one)
    else if ((flags & BLOCK_FIELD_IS_BLOCK) == BLOCK_FIELD_IS_BLOCK)
    {
        // copying a Block declared variable from the stack Block to the heap
        _Block_assign(_Block_copy_internal(object, flags), destAddr);
    }
    // (this test must be after previous one)
    else if ((flags & BLOCK_FIELD_IS_OBJECT) == BLOCK_FIELD_IS_OBJECT)
    {
        //printf("retaining object at %p\n", object);
        _Block_retain_object(object);
        //printf("done retaining object at %p\n", object);
        _Block_assign((void *)object, destAddr);
    }
}


static void _Block_byref_assign_copy(void *dest, const void *arg, const int flags)
{
    struct Block_byref **destp = (struct Block_byref **)dest;
    struct Block_byref *src = (struct Block_byref *)arg;
    if (src->forwarding->flags & BLOCK_IS_GC)
    {
        ;   // don't need to do any more work
    }
    else if ((src->forwarding->flags & BLOCK_REFCOUNT_MASK) == 0)
    {
        //printf("making copy\n");
        // src points to stack
        bool isWeak = ((flags & (BLOCK_FIELD_IS_BYREF|BLOCK_FIELD_IS_WEAK)) == (BLOCK_FIELD_IS_BYREF|BLOCK_FIELD_IS_WEAK));
        // if its weak ask for an object (only matters under GC)
        struct Block_byref *copy = (struct Block_byref *)_Block_allocator(src->size, false, isWeak);
        copy->flags = src->flags | _Byref_flag_initial_value; // non-GC one for caller, one for stack
        copy->forwarding = copy; // patch heap copy to point to itself (skip write-barrier)
        src->forwarding = copy;  // patch stack to point to heap copy
        copy->size = src->size;
        if (isWeak) {
            copy->isa = &_NSConcreteWeakBlockVariable;  // mark isa field so it gets weak scanning
        }
        if (src->flags & BLOCK_HAS_COPY_DISPOSE) {
            // Trust copy helper to copy everything of interest
            // If more than one field shows up in a byref block this is wrong XXX
            copy->byref_keep = src->byref_keep;
            copy->byref_destroy = src->byref_destroy;
            (*src->byref_keep)(copy, src);
        }
        else {
            // just bits.  Blast 'em using _Block_memmove in case they're __strong
            _Block_memmove(
                           (void *)&copy->byref_keep,
                           (void *)&src->byref_keep,
                           src->size - sizeof(struct Block_byref_header));
        }
    }
    // already copied to heap
    else if ((src->forwarding->flags & BLOCK_NEEDS_FREE) == BLOCK_NEEDS_FREE) {
        latching_incr_int(&src->forwarding->flags);
    }
    // assign byref data block pointer into new Block
    _Block_assign(src->forwarding, (void **)destp);
}
</code></pre>


<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>对如下3个Person类分别做[[Person alloc] init]和[Person release]，查看Person类中dealloc是否会调用。</p>
<p>类A PersonA：</p>
<pre><code>typedef int (^square)(int);

#import "Person.h"


@interface Person ()
{
    square tempBlock;
}

@property (nonatomic, assign) int i;

@end


@implementation Person

- (id) init
{
    self = [super init];
    if (self)
    {
        _i = 8;
        tempBlock = ^(int a){
            return a * _i;
        };

        NSLog(@"tempBlock:%@", tempBlock);
    }

    return self;
}


- (void) funTest
{
    NSLog(@"tmpBlock:%d", tempBlock(5));
}


- (void) dealloc
{
    [super dealloc];

    NSLog(@"dealloc run");
}

@end</code></pre>

<p>类B:PersonB：</p>
<pre><code>typedef int (^square)(int);

#import "Person1.h"


@interface Person1 ()
{
    square tempBlock;
}

@property (nonatomic, assign) int i;

@end

@implementation Person1


- (id) init
{
    self = [super init];
    if (self)
    {
        _i = 8;
        square tempBlock1 = ^(int a){
            return a * _i;
        };

        tempBlock = [tempBlock1 copy];

        NSLog(@"tempBlock:%@, temptBlock1:%@", tempBlock, tempBlock1);
    }

    return self;
}


- (void) funTest
{
    NSLog(@"tmpBlock:%d", tempBlock(5));
}


- (void) dealloc
{
    [super dealloc];

    NSLog(@"dealloc run");
}

@end
</code></pre>

<p>类C：PersonC:</p>
<pre><code>typedef int (^square)(int);

#import "Person2.h"

@interface Person2 ()
{
    square tempBlock;
}

@property (nonatomic, assign) int i;

@end


@implementation Person2


- (id) init
{
    self = [super init];
    if (self)
    {
        _i = 8;
        __block Person2* weakSelf = self;
        square tempBlock1 = ^(int a){
            return a * weakSelf.i;
        };

        tempBlock = [tempBlock1 copy];

        NSLog(@"tempBlock:%@, temptBlock1:%@", tempBlock, tempBlock1);
    }

    return self;
}


- (void) funTest
{
    NSLog(@"tmpBlock:%d", tempBlock(5));
}


- (void) dealloc
{
    [super dealloc];

    NSLog(@"dealloc run");
}

@end</code></pre>

<p>发现：</p>
<ol>
<li>A和C的dealloc会调用，而B的dealloc不会调用</li>
<li>A中的block为栈的block，B和C的tempBlock为堆的block（从栈中copy了）</li>
<li>说明栈的block不会强引用self，而堆的block会强引用self。如果加上__block Person2* weakSelf = self;时，再在block中访问weakSelf的变量就不会强引用weakSelf。</li>
</ol>
<p>为什么？</p>
<h3 id="本质实现探究"><a href="#本质实现探究" class="headerlink" title="本质实现探究"></a>本质实现探究</h3><p>查看源码实现，就知道栈上的blockcopy到堆上时，对person对象进行了retain，而当person对象加上__block时，block内部就不会对person进行retain了。具体如下：<br>对person1代码进行clang查看源码如下：</p>
<pre><code>struct __block_impl 
{
    void *isa;
    int Flags;
    int Reserved;
    void *FuncPtr;
};

struct Person1_IMPL
{
    struct NSObject_IMPL NSObject_IVARS;
    square tempBlock;
    int _i;
};

struct __Person1__init_block_impl_0 
{
   struct __block_impl impl;
   struct __Person1__init_block_desc_0* Desc;
   Person1 *self;
   __Person1__init_block_impl_0(void *fp, struct __Person1__init_block_desc_0 *desc, Person1 *_self, int flags=0) : self(_self) 
   {
     impl.isa = &_NSConcreteStackBlock;
     impl.Flags = flags;
     impl.FuncPtr = fp;
     Desc = desc;
  }
};

static int __Person1__init_block_func_0(struct __Person1__init_block_impl_0 *__cself, int a) 
{
    Person1 *self = __cself->self; // bound by copy
    return a * (*(int *)((char *)self + OBJC_IVAR_$_Person1$_i));
}

static void __Person1__init_block_copy_0(struct __Person1__init_block_impl_0*dst, struct __Person1__init_block_impl_0*src) 
{
    _Block_object_assign((void*)&dst->self, (void*)src->self, 3/     
    *BLOCK_FIELD_IS_OBJECT*/);
}


static void __Person1__init_block_dispose_0(struct __Person1__init_block_impl_0*src) 
{
   _Block_object_dispose((void*)src->self, 3/*BLOCK_FIELD_IS_OBJECT*/);
}


static struct __Person1__init_block_desc_0 
{
    size_t reserved;
    size_t Block_size;
    void (*copy)(struct __Person1__init_block_impl_0*, struct __Person1__init_block_impl_0*);
    void (*dispose)(struct __Person1__init_block_impl_0*);
} __Person1__init_block_desc_0_DATA = { 0, sizeof(struct __Person1__init_block_impl_0), __Person1__init_block_copy_0, __Person1__init_block_dispose_0};


static id _I_Person1_init(Person1 * self, SEL _cmd) 
{
    self = ((Person1 *(*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){(id)self, (id)class_getSuperclass(objc_getClass("Person1"))}, sel_registerName("init"));
    if (self)
    {
        (*(int *)((char *)self + OBJC_IVAR_$_Person1$_i)) = 8;
        square tempBlock1 = ((int (*)(int))&__Person1__init_block_impl_0((void *)__Person1__init_block_func_0, &__Person1__init_block_desc_0_DATA, self, 570425344));

        (*(square *)((char *)self + OBJC_IVAR_$_Person1$tempBlock)) = (square)((id (*)(id, SEL))(void *)objc_msgSend)((id)tempBlock1, sel_registerName("copy"));

        NSLog((NSString *)&__NSConstantStringImpl__var_folders_4x_l4ckkvk570s3grlbg_9fdk_40000gn_T_Person1_617ecb_mi_0, (*(square *)((char *)self + OBJC_IVAR_$_Person1$tempBlock)), tempBlock1);
    }

    return self;
}

static void _I_Person1_funTest(Person1 * self, SEL _cmd) 
{
    NSLog((NSString *)&__NSConstantStringImpl__var_folders_4x_l4ckkvk570s3grlbg_9fdk_40000gn_T_Person1_617ecb_mi_1, ((int (*)(__block_impl *, int))((__block_impl *)(*(square *)((char *)self + OBJC_IVAR_$_Person1$tempBlock)))->FuncPtr)((__block_impl *)(*(square *)((char *)self + OBJC_IVAR_$_Person1$tempBlock)), 5));
}

static void _I_Person1_dealloc(Person1 * self, SEL _cmd) 
{
    ((void (*)(__rw_objc_super *, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){(id)self, (id)class_getSuperclass(objc_getClass("Person1"))}, sel_registerName("dealloc"));

    NSLog((NSString *)&__NSConstantStringImpl__var_folders_4x_l4ckkvk570s3grlbg_9fdk_40000gn_T_Person1_617ecb_mi_2);
}

static int _I_Person1_i(Person1 * self, SEL _cmd) { return (*(int *)((char *)self + OBJC_IVAR_$_Person1$_i)); }
static void _I_Person1_setI_(Person1 * self, SEL _cmd, int i) { (*(int *)((char *)self + OBJC_IVAR_$_Person1$_i)) = i; }
// @end</code></pre>

<p>结合runtime.h查看上面代码的执行过程：</p>
<ol>
<li>先执行_I_Person1_init这个函数，执行block的copy。查看runtime.h中block_copy会执行_Block_copy_internal</li>
<li>执行_Block_copy_internal(const void <em>arg, const int flags)中<pre><code>struct Block_layout </code></pre></em>aBlock;<br> // The following would be better done as a switch statement<br> aBlock = (struct Block_layout *)arg;// Its a stack block.  Make a copy.<br> if (!isGC) {<pre><code>struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);
if (!result) return (void *)0;
memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first
// reset refcount
result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed
result-&gt;flags |= BLOCK_NEEDS_FREE | 1;
result-&gt;isa = _NSConcreteMallocBlock;
if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
    //printf(&quot;calling block copy helper %p(%p, %p)...\n&quot;, aBlock-&gt;descriptor-&gt;copy, result, aBlock);
    (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup
}
return result;
</code></pre> }  </li>
<li>执行上面对栈上的block进行copy，在堆上生成新的内存块，flag为BLOCK_NEEDS_FREE和~(BLOCK_REFCOUNT_MASK)记得这个后面会用。isa声明为堆的block。然后执行(*aBlock-&gt;descriptor-&gt;copy)(result, aBlock)即上面的<strong>Person1</strong>init_block_copy_0函数</li>
<li>执行_Block_object_assign((void<em>)&amp;dst-&gt;self, (void</em>)src-&gt;self, 3/<br> <em>BLOCK_FIELD_IS_OBJECT</em>/);查看runtime.h查看其实现。</li>
<li>执行的代码如下：<pre><code>void _Block_object_assign(void <em>destAddr, const void </em>object, const int flags)<br>{<br> // (this test must be after previous one)<br> else if ((flags &amp; BLOCK_FIELD_IS_OBJECT) == BLOCK_FIELD_IS_OBJECT) {<pre><code>//printf(&quot;retaining object at %p\n&quot;, object);
_Block_retain_object(object);
//printf(&quot;done retaining object at %p\n&quot;, object);
_Block_assign((void *)object, destAddr);
</code></pre> }<br>}</code></pre></li>
<li>对object即src-&gt;self即block持有的person进行了retain,而_block_assign把栈上持有的person对象的内存地址赋值到堆上面person的对象的地址。这样指向一个person对象就可以直接操作person对象的变量和值。</li>
</ol>
<p>同样对person2进行源码编译，查看runtime.c，也详细分析下步骤 编译后的源码：<pre><code>struct __block_impl {<br>  void <em>isa;<br>  int Flags;<br>  int Reserved;<br>  void </em>FuncPtr;};</code></pre></p>
<p>static void <strong>Block_byref_id_object_copy_131(void <em>dst, void </em>src) {<br>   // 4个指针加上2个int 4<em>8+2</em>4=40即</strong>Block_byref_weakSelf_0中的person对象 131即为BLOCK_FIELD_IS_OBJECT|BLOCK_BYREF_CALLE<br>   _Block_object_assign((char<em>)dst + 40, </em>(void <em> </em>) ((char<em>)src + 40), 131);<br>}<br>static void __Block_byref_id_object_dispose_131(void </em>src) {<br> _Block_object_dispose(<em>(void </em> <em>) ((char</em>)src + 40), 131);<br>}<br>static <strong>NSConstantStringImpl </strong>NSConstantStringImpl<strong>var_folders_4x_l4ckkvk570s3grlbg_9fdk_40000gn_T_Person2_62cdd7_mi_0 </strong>attribute<strong> ((section (“</strong>DATA, <strong>cfstring”))) = {</strong>CFConstantStringClassReference,0x000007c8,”tempBlock:%@, temptBlock1:%@”,28};<br>static <strong>NSConstantStringImpl </strong>NSConstantStringImpl<strong>var_folders_4x_l4ckkvk570s3grlbg_9fdk_40000gn_T_Person2_62cdd7_mi_1 </strong>attribute<strong> ((section (“</strong>DATA, <strong>cfstring”))) = {</strong>CFConstantStringClassReference,0x000007c8,”tmpBlock:%d”,11};<br>static <strong>NSConstantStringImpl </strong>NSConstantStringImpl<strong>var_folders_4x_l4ckkvk570s3grlbg_9fdk_40000gn_T_Person2_62cdd7_mi_2 </strong>attribute<strong> ((section (“</strong>DATA, <strong>cfstring”))) = {</strong>CFConstantStringClassReference,0x000007c8,”dealloc run”,11};</p>
<p>struct <strong>Block_byref_weakSelf_0 {<br>  void *</strong>isa;<br><strong>Block_byref_weakSelf_0 *</strong>forwarding;<br> int <strong>flags;<br> int </strong>size;<br> void (<em>__Block_byref_id_object_copy)(void</em>, void<em>);<br> void (</em>__Block_byref_id_object_dispose)(void<em>);<br> Person2 </em>weakSelf;<br>};</p>
<p>struct <strong>Person2</strong>init_block_impl_0 {<br>  struct <strong>block_impl impl;<br>  struct </strong>Person2<strong>init_block_desc_0* Desc;
  </strong>Block_byref_weakSelf_0 <em>weakSelf; // by ref<br>  <strong>Person2</strong>init_block_impl_0(void </em>fp, struct <strong>Person2</strong>init_block_desc_0 <em>desc, __Block_byref_weakSelf_0 </em>_weakSelf, int flags=0) : weakSelf(_weakSelf-&gt;__forwarding) {<br>    impl.isa = &amp;_NSConcreteStackBlock;<br>    impl.Flags = flags;<br>    impl.FuncPtr = fp;<br>    Desc = desc;<br>  }<br>};</p>
<p>static int <strong>Person2</strong>init_block_func_0(struct <strong>Person2</strong>init_block_impl_0 <em><strong>cself, int a)<br>{
    </strong>Block_byref_weakSelf_0 </em>weakSelf = <strong>cself-&gt;weakSelf; // bound by ref<br>    return a <em> ((int (</em>)(id, SEL))(void *)objc_msgSend)((id)(weakSelf-&gt;</strong>forwarding-&gt;weakSelf), sel_registerName(“i”));<br>}</p>
<p>static void <strong>Person2</strong>init_block_copy_0(struct <strong>Person2</strong>init_block_impl_0<em>dst, struct <strong>Person2</strong>init_block_impl_0</em>src)<br>{<br>    _Block_object_assign((void<em>)&amp;dst-&gt;weakSelf, (void</em>)src-&gt;weakSelf, 8/<em>BLOCK_FIELD_IS_BYREF</em>/);<br>}</p>
<p>static void <strong>Person2</strong>init_block_dispose_0(struct <strong>Person2</strong>init_block_impl_0<em>src)<br>{<br>    _Block_object_dispose((void</em>)src-&gt;weakSelf, 8/<em>BLOCK_FIELD_IS_BYREF</em>/);<br>}</p>
<p>static struct <strong>Person2</strong>init_block_desc_0<br>{<br>  size_t reserved;<br>  size_t Block_size;<br>  void (<em>copy)(struct <strong>Person2</strong>init_block_impl_0</em>, struct <strong>Person2</strong>init_block_impl_0<em>);<br>  void (</em>dispose)(struct <strong>Person2</strong>init_block_impl_0*);<br>} <strong>Person2</strong>init_block_desc_0_DATA = { 0, sizeof(struct <strong>Person2</strong>init_block_impl_0), <strong>Person2</strong>init_block_copy_0, <strong>Person2</strong>init_block_dispose_0};</p>
<p>static id _I_Person2_init(Person2 <em> self, SEL _cmd) {<br>    self = ((Person2 </em>(<em>)(__rw_objc_super </em>, SEL))(void <em>)objc_msgSendSuper)((__rw_objc_super){(id)self, (id)class_getSuperclass(objc_getClass(“Person2”))}, sel_registerName(“init”));<br>    if (self)<br>    {<br>       //33554432即为BLOCK_HAS_COPY_DISPOSE<br>       (</em>(int <em>)((char </em>)self + OBJC<em>IVAR</em>$_Person2$_i)) = 8;<br>        <strong>attribute</strong>((<strong>blocks</strong>(byref))) <strong>Block_byref_weakSelf_0 weakSelf = {(void*)0,(</strong>Block_byref_weakSelf_0 <em>)&amp;weakSelf, 33554432, sizeof(<strong>Block_byref_weakSelf_0), </strong>Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, self};<br>        square tempBlock1 = ((int (</em>)(int))&amp;<strong>Person2</strong>init_block_impl_0((void <em>)<strong>Person2</strong>init_block_func_0, &amp;<strong>Person2</strong>init_block_desc_0_DATA, (__Block_byref_weakSelf_0 </em>)&amp;weakSelf, 570425344));<br>     (<em>(square </em>)((char <em>)self + OBJC<em>IVAR</em>$_Person2$tempBlock)) = (square)((id (</em>)(id, SEL))(void <em>)objc_msgSend)((id)tempBlock1, sel_registerName(“copy”));<br>     NSLog((NSString </em>)&amp;<strong>NSConstantStringImpl</strong>var_folders_4x_l4ckkvk570s3grlbg_9fdk_40000gn_T_Person2_62cdd7_mi_0, (<em>(square </em>)((char *)self + OBJC<em>IVAR</em>$_Person2$tempBlock)), tempBlock1);<br>    }<br>    return self;<br>}</p>
<p>static void _I_Person2_funTest(Person2 <em> self, SEL _cmd)<br>{<br>    NSLog((NSString </em>)&amp;<strong>NSConstantStringImpl</strong>var_folders_4x_l4ckkvk570s3grlbg_9fdk_40000gn_T_Person2_62cdd7_mi_1, ((int (<em>)(__block_impl </em>, int))((<strong>block_impl <em>)(</em>(square <em>)((char </em>)self + OBJC<em>IVAR</em>$_Person2$tempBlock)))-&gt;FuncPtr)((</strong>block_impl <em>)(</em>(square <em>)((char </em>)self + OBJC<em>IVAR</em>$_Person2$tempBlock)), 5));<br>}</p>
<p>static void _I_Person2_dealloc(Person2 <em> self, SEL _cmd)<br>{<br>    ((void (</em>)(<strong>rw_objc_super <em>, SEL))(void </em>)objc_msgSendSuper)((</strong>rw_objc_super){(id)self, (id)class_getSuperclass(objc_getClass(“Person2”))}, sel_registerName(“dealloc”));<br>    ((void (<em>)(id, SEL))(void </em>)objc_msgSend)((id)(<em>(square </em>)((char <em>)self + OBJC<em>IVAR</em>$_Person2$tempBlock)), sel_registerName(“release”));<br>    NSLog((NSString </em>)&amp;<strong>NSConstantStringImpl</strong>var_folders_4x_l4ckkvk570s3grlbg_9fdk_40000gn_T_Person2_62cdd7_mi_2);<br>}</p>
<p>static int _I_Person2_i(Person2 <em> self, SEL _cmd) { return (</em>(int <em>)((char </em>)self + OBJC<em>IVAR</em>$_Person2$_i)); }<br>static void _I_Person2<em>setI</em>(Person2 <em> self, SEL _cmd, int i) { (</em>(int <em>)((char </em>)self + OBJC<em>IVAR</em>$_Person2$_i)) = i; }<br></p>
<p>执行步骤：</p>
<ol>
<li>执行_I_Person2_init，生成__Block_byref_weakSelf_0中weakSelf,用weakSelf生成tempBlock对象。执行tempBlock的copy。</li>
<li><p>同样执行_Block_copy_internal(const void <em>arg, const int flags)中<pre><code>struct Block_layout </code></pre></em>aBlock;<br> // The following would be better done as a switch statement<br> aBlock = (struct Block_layout *)arg;// Its a stack block.  Make a copy.<br> if (!isGC) {</p>
<pre><code>struct Block_layout *result = malloc(aBlock-&gt;descriptor-&gt;size);
if (!result) return (void *)0;
memmove(result, aBlock, aBlock-&gt;descriptor-&gt;size); // bitcopy first
// reset refcount
result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK);    // XXX not needed
result-&gt;flags |= BLOCK_NEEDS_FREE | 1;
result-&gt;isa = _NSConcreteMallocBlock;
if (result-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
    //printf(&quot;calling block copy helper %p(%p, %p)...\n&quot;, aBlock-&gt;descriptor-&gt;copy, result, aBlock);
    (*aBlock-&gt;descriptor-&gt;copy)(result, aBlock); // do fixup
}
return result;
</code></pre><p> }</p>
</li>
<li><p>执行上面对栈上的block进行copy，在堆上生成新的内存块，flag为BLOCK_NEEDS_FREE和~(BLOCK_REFCOUNT_MASK)记得这个后面会用。isa声明为堆的block。然后执行(*aBlock-&gt;descriptor-&gt;copy)(result, aBlock)即上面的<strong>Person2</strong>init_block_copy_0函数</p>
</li>
<li>执行<pre><code>static void <strong>Person2</strong>init_block_copy_0(struct <strong>Person2</strong>init_block_impl_0<em>dst, struct <strong>Person2</strong>init_block_impl_0</em>src)<br>{<br> _Block_object_assign((void<em>)&amp;dst-&gt;weakSelf, (void</em>)src-&gt;weakSelf, 8/<em>BLOCK_FIELD_IS_BYREF</em>/);<br>}</code></pre></li>
<li>查看runtime.h执行<pre><code>void _Block_object_assign(void <em>destAddr, const void </em>object, const int flags) {<br> else if ((flags &amp; BLOCK_FIELD_IS_BYREF) == BLOCK_FIELD_IS_BYREF)  {<pre><code>// copying a __block reference from the stack Block to the heap
// flags will indicate if it holds a __weak reference and needs a special isa
_Block_byref_assign_copy(destAddr, object, flags);
</code></pre> }</code></pre></li>
<li><p>执行<pre><code>static void _Block_byref_assign_copy(void <em>dest, const void </em>arg, const int flags) {<br> struct Block_byref <strong>destp = (struct Block_byref </strong>)dest;<br> struct Block_byref <em>src = (struct Block_byref </em>)arg;</code></pre></p>
<p> else if ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == 0) {</p>
<pre><code>//printf(&quot;making copy\n&quot;);
// src points to stack
bool isWeak = ((flags &amp; (BLOCK_FIELD_IS_BYREF|BLOCK_FIELD_IS_WEAK)) == (BLOCK_FIELD_IS_BYREF|BLOCK_FIELD_IS_WEAK));
// if its weak ask for an object (only matters under GC)
struct Block_byref *copy = (struct Block_byref *)_Block_allocator(src-&gt;size, false, isWeak);
copy-&gt;flags = src-&gt;flags | _Byref_flag_initial_value; // non-GC one for caller, one for stack
copy-&gt;forwarding = copy; // patch heap copy to point to itself (skip write-barrier)
src-&gt;forwarding = copy;  // patch stack to point to heap copy
copy-&gt;size = src-&gt;size;
if (isWeak) {
    copy-&gt;isa = &amp;_NSConcreteWeakBlockVariable;  // mark isa field so it gets weak scanning
}
if (src-&gt;flags &amp; BLOCK_HAS_COPY_DISPOSE) {
    // Trust copy helper to copy everything of interest
    // If more than one field shows up in a byref block this is wrong XXX
    copy-&gt;byref_keep = src-&gt;byref_keep;
    copy-&gt;byref_destroy = src-&gt;byref_destroy;
    (*src-&gt;byref_keep)(copy, src);
}
</code></pre><p> }<br> 其中最后(<em>src-&gt;byref_keep)(copy, src);即为：<strong>Block_byref_id_object_copy_131，static void </strong>Block_byref_id_object_copy_131(void </em>dst, void <em>src) {<br>// 4个指针加上2个int 4</em>8+2<em>4=40即__Block_byref_weakSelf_0中的person对象 131即为BLOCK_FIELD_IS_OBJECT|BLOCK_BYREF_CALLE<br>_Block_object_assign((char</em>)dst + 40, <em>(void </em> <em>) ((char</em>)src + 40), 131);<br>}</p>
</li>
<li>查看runTime.h<pre><code>void _Block_object_assign(void <em>destAddr, const void </em>object, const int flags) {<br> //printf(“_Block_object_assign(*%p, %p, %x)\n”, destAddr, object, flags);<br> if ((flags &amp; BLOCK_BYREF_CALLER) == BLOCK_BYREF_CALLER) {<pre><code>if ((flags &amp; BLOCK_FIELD_IS_WEAK) == BLOCK_FIELD_IS_WEAK) {
    _Block_assign_weak(object, destAddr);
}
else {
    // do *not* retain or *copy* __block variables whatever they are
    _Block_assign((void *)object, destAddr);
}
</code></pre> }<br> }</code></pre>中执行_Block_assign即只把最初栈中person的指针赋值到堆中。不会对person进行retain。也所以不会造成循环引用。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/18/Block/" data-id="cio5cn3eb0006hwzxm2gdhkxy" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/block/">block</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-TextAndImage" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/18/TextAndImage/" class="article-date">
  <time datetime="2016-04-18T08:36:28.000Z" itemprop="datePublished">2016-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/18/TextAndImage/">文字和图片混排</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="文字和图片"><a href="#文字和图片" class="headerlink" title="文字和图片"></a>文字和图片</h2><p>其实这个内容蛮早了，只是今天整理到博客上。自从有了IOS7后，文字的颜色和文字与图片的混排甚至把图片作为表情都可以轻松地实现了。不打算书写了，主体代码粘贴如下，需要细看的直接下载附件就可以了。<a href="http://7xt51v.com2.z0.glb.clouddn.com/TypesettingsShare.zip" target="_blank" rel="external">代码下载</a></p>
<pre><code>@interface MMTextAttachment : NSTextAttachment
{

}

@end

@implementation MMTextAttachment

//I want my emoticon has the same size with line's height
- (CGRect)attachmentBoundsForTextContainer:(NSTextContainer *)textContainer proposedLineFragment:(CGRect)lineFrag glyphPosition:(CGPoint)position characterIndex:(NSUInteger)charIndex NS_AVAILABLE_IOS(7_0)
{
    return CGRectMake( 0 , 0 , lineFrag.size.height , lineFrag.size.height );
}

@end


@interface ViewController ()
<uitextviewdelegate>
{
    UILabel *lbInfo;
    UITextView *textView;
}
@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view, typically from a nib.

    // 添加控件
     [self customizeTheLb];

    // 添加TextView
     [self customizeTheTextView];

    // 显示不同的颜色
//    [self customizeDifferentColors];

    // 正则匹配,特殊显示匹配到的文字
   // [self createRegularExpressionText];

    // 显示不同的文本样式
   // [self customizeDifferentStyles];

    // 取出某个区域
   // [self customizeExceptSomeZone1];


//   [self customizeExceptSomeZone2];

    // 图片融入文字，作为表情
    [self customizeExceptSomeZone3];
}


- (void) customizeTheLb
{
    lbInfo = [[UILabel alloc] init];
    [self.view addSubview:lbInfo];
    lbInfo.numberOfLines = -1;
    [lbInfo setTranslatesAutoresizingMaskIntoConstraints:NO];

    [self.view addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"H:|-10-[lbInfo]-10-|" options:0 metrics:nil views:NSDictionaryOfVariableBindings(lbInfo)]];
    [self.view addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"V:|-40-[lbInfo]" options:0 metrics:nil views:NSDictionaryOfVariableBindings(lbInfo)]];
}


- (void) customizeTheTextView
{
    textView = [[UITextView alloc] init];
    [self.view addSubview:textView];
    [textView setTranslatesAutoresizingMaskIntoConstraints:NO];

    [self.view addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"H:|-0-[textView]-0-|" options:0 metrics:nil views:NSDictionaryOfVariableBindings(textView)]];
    [self.view addConstraints:[NSLayoutConstraint constraintsWithVisualFormat:@"V:|-20-[textView]-0-|" options:0 metrics:nil views:NSDictionaryOfVariableBindings(textView)]];

    textView.delegate = self;
    textView.selectable = NO;
    textView.text = @"wodeceshi";
}


// 显示不同的颜色
- (void)customizeDifferentColors
{
    NSMutableString *roadInfo = [NSMutableString stringWithString:@"沿无名道路\r向枫涟山庄5号楼出发"];

    NSLog(@"roadInfo:%@", roadInfo);

    UIFont *font1 = [UIFont boldSystemFontOfSize:28];
    UIColor *textColor1 = [UIColor blackColor];

    UIFont *font2 = [UIFont preferredFontForTextStyle:UIFontTextStyleBody];
    UIColor *textColor2 = [UIColor colorWithRed:0.175 green:0.458 blue:0.831 alpha:1.0];

    NSDictionary *attrs1 = @{
                             NSForegroundColorAttributeName:textColor1,
                             NSFontAttributeName:font1
                             };
    NSRange range1 = [roadInfo rangeOfString:@"无名道路"];

    NSDictionary *attrs2 = @{
                            NSForegroundColorAttributeName:textColor2,
                            NSFontAttributeName:font2
                            };
    NSRange range2 = [roadInfo rangeOfString:@"枫涟山庄5号楼"];

    NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:roadInfo];
    if (range1.location != NSNotFound)
    {
        [attributedStr addAttributes:attrs1 range:range1];
    }
    if (range2.location != NSNotFound)
    {
        [attributedStr addAttributes:attrs2 range:range2];
    }
    lbInfo.attributedText = attributedStr;


    lbInfo.preferredMaxLayoutWidth = 200;
    lbInfo.backgroundColor = [UIColor yellowColor];
    CGSize size = [lbInfo systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];
    NSLog(@"--height:%f", size.height);
}



- (void) createRegularExpressionText
{
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"孙某人" options:0 error:Nil];
    NSMutableString *regularInfo = [NSMutableString stringWithString:@"这个测试孙某人信息显示正确与否--孙某人"];
    NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:regularInfo];
    NSRange searchRange = NSMakeRange(0, regularInfo.length);

    UIFont *font = [UIFont boldSystemFontOfSize:18];
    UIColor *textColor = [UIColor blueColor];

    NSDictionary *attrs = @{
                             NSForegroundColorAttributeName:textColor,
                             NSFontAttributeName:font
                             };

    [regex enumerateMatchesInString:regularInfo options:0 range:searchRange usingBlock:^(NSTextCheckingResult *match, NSMatchingFlags flags, BOOL *stop){
        NSRange matchRange = [match rangeAtIndex:0];
        [attributedStr addAttributes:attrs range:matchRange];
    }];

    lbInfo.attributedText = attributedStr;
}


// 文本显示不同的样式
- (void) customizeDifferentStyles
{
    NSMutableString *roadInfo = [NSMutableString stringWithString:@"关于农村宅基地改革的问题，目前确实有一个试点方案，已经编制完成了，但还没有最后批准。”23日上午，一位不愿具名的国土资源部内部人士向记者证实，国土资源部已经初步编制完成了农村宅基地制度改革试点方案www.baidu.com。\r所谓农村宅基地，是农村的农户或个人用作住宅基地而占有、利用本集体所有的土地。包括已经建设房屋、建过房屋或者决定用于建造房屋的土地，已经建设房屋的土地、建过房屋但已无上盖物或不能居住的土地以及准备建房用的规划地三种类型。\r据悉，按照目前已经基本成型的“试点方案”，农村宅基地改革试点工作将按照“分类处理”原则的进行。所谓分类，即“城乡建设用地扩展边界外的传统农区”和“城乡建设用地扩展边界内”两类，对于这两类不同情况，将以不同方式贯彻“一户一宅”的原则。"];

    UIFont *font = [UIFont systemFontOfSize:18];
    UIColor *textColor = [UIColor blackColor];
    NSMutableParagraphStyle *parahStyle = [[NSParagraphStyle defaultParagraphStyle] mutableCopy];
    parahStyle.firstLineHeadIndent =20;
   // parahStyle.headIndent = 20;
   // parahStyle.tailIndent = 10;
   // parahStyle.lineSpacing = 90;
   // parahStyle.paragraphSpacing = 20;
   // parahStyle.paragraphSpacingBefore = 80;


    NSDictionary *attrs = @{
                             NSForegroundColorAttributeName:textColor,
                             NSFontAttributeName:font,
                             NSParagraphStyleAttributeName:parahStyle,
                             NSKernAttributeName:@10,
                            // NSUnderlineStyleAttributeName:@1,
                            // NSStrokeWidthAttributeName:@2
                             };
    NSRange range = NSMakeRange(0, roadInfo.length);

    NSMutableAttributedString *attributedStr = [[NSMutableAttributedString alloc] initWithString:roadInfo];
    [attributedStr addAttributes:attrs range:range];

    [attributedStr addAttribute:NSLinkAttributeName
                             value:@"link1://www.baidu.com"
                             range:[roadInfo rangeOfString:@"www.baidu.com"]];

    NSDictionary *linkAttributes = @{NSForegroundColorAttributeName: [UIColor greenColor],
                                     NSUnderlineColorAttributeName: [UIColor lightGrayColor],
                                     NSUnderlineStyleAttributeName: @(NSUnderlinePatternSolid)};

    textView.linkTextAttributes = linkAttributes;
    textView.delegate = self;
    textView.editable = NO;
    textView.selectable = YES;

    textView.attributedText = attributedStr;
}


- (void)textViewDidBeginEditing:(UITextView *)textView
{

}


- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text
{



    return YES;
}


/*
- (BOOL) textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange
{
    if ([URL.scheme isEqualToString:@"link1"])
    {
        NSLog(@"点击进入百度网站");

        return NO;
    }

    return YES;
}
*/


- (void) customizeExceptSomeZone1
{
    CGRect rect = CGRectMake(100, 100, 100, 100);

    UIImageView *imageV = [[UIImageView alloc] init];
    imageV.frame = rect;
    imageV.image = [UIImage imageNamed:@"xiang.png"];

    imageV.layer.masksToBounds = YES;
    imageV.layer.cornerRadius = CGRectGetWidth(imageV.frame) / 2.0;
    [textView addSubview:imageV];


    NSMutableString *roadInfo = [NSMutableString stringWithString:@"关于农村宅基地改革的问题，目前确实有一个试点方案，已经编制完成了，但还没有最后批准。”23日上午，一位不愿具名的国土资源部内部人士向记者证实，国土资源部已经初步编制完成了农村宅基地制度改革试点方案www.baidu.com。\r所谓农村宅基地，是农村的农户或个人用作住宅基地而占有、利用本集体所有的土地。包括已经建设房屋、建过房屋或者决定用于建造房屋的土地，已经建设房屋的土地、建过房屋但已无上盖物或不能居住的土地以及准备建房用的规划地三种类型。\r据悉，按照目前已经基本成型的“试点方案”，农村宅基地改革试点工作将按照“分类处理”原则的进行。所谓分类，即“城乡建设用地扩展边界外的传统农区”和“城乡建设用地扩展边界内”两类，对于这两类不同情况，将以不同方式贯彻“一户一宅”的原则。"];
    textView.text = roadInfo;
    textView.font = [UIFont systemFontOfSize:18];

    UIBezierPath *newPath = [UIBezierPath bezierPathWithOvalInRect:imageV.frame];
 //   UIBezierPath *newPath = [UIBezierPath bezierPathWithRect:imageV.frame];
    textView.textContainer.exclusionPaths = @[newPath];

}


- (void) customizeExceptSomeZone2
{
    CGRect rect = CGRectMake(0, 0, 40, 40);
    NSTextAttachment * textAttachment = [[ NSTextAttachment alloc ] initWithData:nil ofType:nil ] ;
    UIImage * smileImage = [ UIImage imageNamed:@"xiang.png" ]  ;  //my emoticon image named a.jpg
    textAttachment.image = smileImage;
    textAttachment.bounds = rect;


    NSMutableString *roadInfo = [NSMutableString stringWithString:@"关于农村宅基地改革的问题，目前确实有一个试点方案，已经编制完成了，但还没有最后批准。”23日上午，一位不愿具名的国土资源部内部人士向记者证实，国土资源部已经初步编制完成了农村宅基地制度改革试点方案www.baidu.com。\r所谓农村宅基地，是农村的农户或个人用作住宅基地而占有、利用本集体所有的土地。包括已经建设房屋、建过房屋或者决定用于建造房屋的土地，已经建设房屋的土地、建过房屋但已无上盖物或不能居住的土地以及准备建房用的规划地三种类型。\r据悉，按照目前已经基本成型的“试点方案”，农村宅基地改革试点工作将按照“分类处理”原则的进行。所谓分类，即“城乡建设用地扩展边界外的传统农区”和“城乡建设用地扩展边界内”两类，对于这两类不同情况，将以不同方式贯彻“一户一宅”的原则。"];
    textView.text = roadInfo;

    NSDictionary *attrs = @{
                            NSFontAttributeName:[UIFont systemFontOfSize:18]
                            };

    NSMutableAttributedString * string = [[ NSMutableAttributedString alloc ] initWithString:roadInfo  attributes:attrs ] ;

    NSAttributedString * textAttachmentString = [ NSAttributedString attributedStringWithAttachment:textAttachment ] ;
    [ string insertAttributedString:textAttachmentString atIndex:20] ;

    textView.attributedText = string ;
}


// 作为文字表情，与文字大小一样，融入文字
- (void) customizeExceptSomeZone3
{
    MMTextAttachment* textAttachment = [[ MMTextAttachment alloc ] initWithData:nil ofType:nil ] ;
    UIImage * smileImage = [ UIImage imageNamed:@"xiang.png" ]  ;  //my emoticon image named a.jpg
    textAttachment.image = smileImage;


    NSMutableString *roadInfo = [NSMutableString stringWithString:@"关于农村宅基地改革的问题，目前确实有一个试点方案，已经编制完成了，但还没有最后批准。”23日上午，一位不愿具名的国土资源部内部人士向记者证实，国土资源部已经初步编制完成了农村宅基地制度改革试点方案www.baidu.com。\r所谓农村宅基地，是农村的农户或个人用作住宅基地而占有、利用本集体所有的土地。包括已经建设房屋、建过房屋或者决定用于建造房屋的土地，已经建设房屋的土地、建过房屋但已无上盖物或不能居住的土地以及准备建房用的规划地三种类型。\r据悉，按照目前已经基本成型的“试点方案”，农村宅基地改革试点工作将按照“分类处理”原则的进行。所谓分类，即“城乡建设用地扩展边界外的传统农区”和“城乡建设用地扩展边界内”两类，对于这两类不同情况，将以不同方式贯彻“一户一宅”的原则。"];
    textView.text = roadInfo;

    NSDictionary *attrs = @{
                            NSFontAttributeName:[UIFont systemFontOfSize:18]
                            };

    NSMutableAttributedString * string = [[ NSMutableAttributedString alloc ] initWithString:roadInfo  attributes:attrs ] ;

    NSAttributedString * textAttachmentString = [ NSAttributedString attributedStringWithAttachment:textAttachment ] ;
    [ string insertAttributedString:textAttachmentString atIndex:20] ;

    textView.attributedText = string ;
}



- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}

@end
</uitextviewdelegate></code></pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/18/TextAndImage/" data-id="cio5cn3e10001hwzx6ug3qz54" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NSMutableAttributedString/">NSMutableAttributedString</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HeapAndStack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/18/HeapAndStack/" class="article-date">
  <time datetime="2016-04-18T07:56:07.000Z" itemprop="datePublished">2016-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/18/HeapAndStack/">深度剖析堆栈</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h2><p>如图：</p>
<p><img src="http://7xt51v.com2.z0.glb.clouddn.com/HeapAndStack-Memory.png" alt=""></p>
<p>Text Segment：文本区也称代码区，通常指用来存放程序执行代码的一块内存区域，区域的大小在程序运行前就已确定，并且内存区域通常属于只读</p>
<p>Data Segment：数据段包含静态的和全局的变量，并且这些变量初始值非0，每个进程都有他自己的数据区。比如：static修饰，const修饰，全局变量等   </p>
<p>Bss Segment：包含静态和全局的变量，但是这些变量的初值是0或者没有赋初值。执行之前默认都会赋值为0</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>以下代码编译后都在Text Segment区域：</p>
<pre><code>int value1;  // bss segment
int value2 = 1; // data segment
static int value3; // bss segment
static int value4 = 12; // data segment
const int value5; // bss segment
const int value6 = 15;  // data segment
void myFunction()
{
      static int someLocalValue = 1;  // data segment
      static int someLocalV1;   // bss segment
}
</code></pre>

<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>栈区(Stack)：<br>     由编译器自动分配释放，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。每当一个函数被调用，该函数返回地址和一些关于调用的信息，比如某些寄存器的内容，被存储到栈区。然后这个被调用的函数再为它的自动变量和临时变量在栈区上分配空间，这就是C实现函数递归调用的方法。每执行一次递归函数调用，一个新的栈框架就会被使用，这样这个新实例栈里的变量就不会和该函数的另一个实例栈里面的变量混淆</p>
<p>堆区(Heap)：<br>     用于动态内存分配。堆在内存中位于bss区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时有可能由OS回收<br>栈：局部变量的值、参数的值、函数返回地址、指针的引用等；自动分配系统释放</p>
<p>堆：自己动态内存分配区域，malloc\new\new []\alloc创建的等；自己分配自己释放</p>
<p>代码示例：</p>
<pre><code>int myFunction()
{
     char *pBuffer;   // 栈上创建一个指针的引用
     bool b = true;   //  栈上创建
     if ( b )
     {
         char buffer[100];   // 创建100字节在栈上
         pBuffer = new char[100];   // 在堆上创建100字节
      }  // buffer在这自动释放，pBuffer没有释放
}  // b释放，pBuffer没有释放，因为没有调用delete []，有内存泄露</code></pre>

<pre><code>void myMethod()
{
     int i = 4;  // 栈上
     int y = 2;   // 栈上
     class1 cls1 = new class1();  // cls1指针在栈上，指针指向的内存在堆上分配          
}</code></pre>



<h3 id="堆："><a href="#堆：" class="headerlink" title="堆："></a>堆：</h3><ol>
<li>内存不连续，有一个链表记录空闲和已使用的内存块，堆上声明一个新的内存块时，同时需要在链表上标记为已使用。</li>
<li>当创建和释放很多小的内存块时，会导致很多不连续的空闲的小内存。这样当在堆区申请一个较大的内存块时，由于这些小内存块都不满足，导致没法使用，虽然各个小内存块之和能够满足，这样就产生了内存的碎片。</li>
<li>相邻的内存块释放后，可以合并形成更大的内存，供后面使用，减少内存碎片。</li>
<li>在应用程序启动时，系统会分配给堆一个有低地址到高地址的内存空间，一个程序通常只有一个堆区，在运行过程中如果内存不够时，堆区会动态向系统申请更多的内存。</li>
<li>堆中创建的内存区域需要自己释放，否则会有内存泄露，在程序退出时整个堆区会全部释放。</li>
<li>不同线程可以同时访问同一堆内存块，所以堆区中需要对不同线程共同访问同一块内存做处理</li>
</ol>
<p><img src="http://7xt51v.com2.z0.glb.clouddn.com/HeapAndStackHeap.png" alt=""></p>
<h3 id="栈："><a href="#栈：" class="headerlink" title="栈："></a>栈：</h3><ol>
<li>目的：调度程序中函数的有序执行（下面会讲）</li>
<li>系统从高地址向低地址分配的内存连续的区域，后进先出</li>
<li>每个线程都会有自己独立的栈，在线程创建时会创建栈并制定栈的大小。（不存在不同线程共同访问同一内存的情况）</li>
<li>回收：线程退出时栈回收，无须手动释放，有系统自动回收</li>
<li>创建速度快（与内存机制有关，就通过2个指针移动，下面会讲）</li>
<li>会有最大的分配限制，通常栈不会太大</li>
<li>如果你需要使用的栈过大时，会导致栈溢出（大部分的程序攻击都是栈溢出，下面会讲）</li>
</ol>
<h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>栈中存放的就是与每个函数对应的栈帧。当函数调用发生时，新的栈帧被压入栈；当函数返回时，相应的栈帧从栈中弹出。典型的栈帧结构如图A-A所示。</p>
<p>栈帧的顶部为函数的实参，下面是函数的返回地址以及前一个栈帧的指针，最下面是分配给函数的局部变量使用的空间。一个栈帧通常都有两个指针，其中一个称为栈低指针：ebp，另一个称为栈顶指针：esp。前者所指向的位置是固定的，而后者所指向的位置在函数的运行过程中可变。因此，在函数中访问实参和局部变量时都是以栈帧指针为基址，再加上一个偏移。对照下图可知，实参的偏移为正，局部变量的偏移为负。</p>
<h4 id="典型的栈帧结构和原理："><a href="#典型的栈帧结构和原理：" class="headerlink" title="典型的栈帧结构和原理："></a>典型的栈帧结构和原理：</h4><p><img src="http://7xt51v.com2.z0.glb.clouddn.com/HeapAndStackWithStackFrame.png" alt=""></p>
<p>代码示例：</p>
<p><img src="http://7xt51v.com2.z0.glb.clouddn.com/HeapAndStackStackFrameCodeExample1.png" alt=""></p>
<h4 id="汇编代码："><a href="#汇编代码：" class="headerlink" title="汇编代码："></a>汇编代码：</h4><pre><code>myExample.c编译生成的汇编代码myExample.s（gcc -S myExample.c -o myExample.s）

1    .file   "example1.c"
2     .version    "01.01"
3 gcc2_compiled.:
4 .text
5     .align 4
6 .globl function
7     .type    function,@function
8 function:
9     pushl %ebp
10     movl %esp,%ebp
11     subl $20,%esp
12     movl 8(%ebp),%eax
13     addl 12(%ebp),%eax
14     movl 16(%ebp),%edx
15     addl %eax,%edx
16     movl %edx,-20(%ebp)
17     movl -20(%ebp),%eax
18     jmp .L1
19     .align 4
20 .L1:
21     leave
22     ret
23 .Lfe1:
24     .size    function,.Lfe1-function
25     .align 426 .globl main
27     .type    main,@function
28 main:
29     pushl %ebp
30    movl %esp,%ebp
31     subl $4,%esp
32     pushl $3
33     pushl $2
34     pushl $1
35     call function
36     addl $12,%esp
37     movl %eax,%eax
38     movl %eax,-4(%ebp)
39 .L2:
40     leave
41     ret
42 .Lfe2:
43     .size    main,.Lfe2-main
44     .ident  "GCC: (GNU) 2.7.2.3”
</code></pre>

<p>注释：使用不同的Gcc版本或者base汇编结果可能会不一样，但基本原理和思路都一样，本文中所有示例程序的编译运行环境为gcc 2.7.2.3以及bash 1.14.7</p>
<h4 id="汇编几个相关的指令："><a href="#汇编几个相关的指令：" class="headerlink" title="汇编几个相关的指令："></a>汇编几个相关的指令：</h4><p>压栈(push)：栈顶指针ESP减小4个字节；以字节为单位将寄存器数据(四字节，不足补零)压入堆栈，从高到低按字节依次将数据存入ESP-1、ESP-2、ESP-3、ESP-4指向的地址单元。</p>
<p>出栈(pop)：栈顶指针ESP指向的栈中数据被取回到寄存器；栈顶指针ESP增加4个字节。<br>调用(call)：将当前的指令指针EIP(该指针指向紧接在call指令后的下条指令)压入堆栈，以备返回时能恢复执行下条指令；然后设置EIP指向被调函数代码开始处，以跳转到被调函数的入口地址执行。</p>
<p>离开(leave)： 恢复主调函数的栈帧以准备返回。等价于指令序列movl %ebp, %esp(恢复原ESP值，指向被调函数栈帧开始处)和popl %ebp(恢复原ebp的值，即主调函数帧基指针)。</p>
<p>返回(ret)：与call指令配合，用于从函数或过程返回。从栈顶弹出返回地址(之前call指令保存的下条指令地址)到EIP寄存器中，程序转到该地址处继续执行(此时ESP指向进入函数时的第一个参数)。若带立即数，ESP再加立即数(丢弃一些在执行call前入栈的参数)。使用该指令前，应使当前栈顶指针所指向位置的内容正好是先前call指令保存的返回地址。</p>
<p>创建栈区（sub <n>, %esp）：将栈顶指针%esp减去指定字节数(栈顶下移)，即为被调函数局部变量开辟栈空间。<n>为立即数且通常为16的整数倍(可能大于局部变量字节总数而稍显浪费，但gcc采用该规则保证数据的严格对齐以有效运用各种优化编译技术)</n></n></p>
<p>赋值（mov %esp, %ebp）：将主调函数的栈顶指针%esp赋给被调函数帧基指针%ebp。此时，%ebp指向被调函数新栈帧的起始地址(栈底)，亦即旧%ebp入栈后的栈顶</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/18/HeapAndStack/" data-id="cio5cn3dw0000hwzxfm1ax99a" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/堆栈/">堆栈</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/18/hello-world/" class="article-date">
  <time datetime="2016-04-18T06:38:33.000Z" itemprop="datePublished">2016-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/18/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<p>######以上保存，以便刚开始随时书写时查阅语法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/18/hello-world/" data-id="cio5cn3e70003hwzxhnf5u266" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/NSMutableAttributedString/">NSMutableAttributedString</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/block/">block</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/copy/">copy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/堆栈/">堆栈</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/NSMutableAttributedString/" style="font-size: 10px;">NSMutableAttributedString</a> <a href="/tags/block/" style="font-size: 10px;">block</a> <a href="/tags/copy/" style="font-size: 10px;">copy</a> <a href="/tags/堆栈/" style="font-size: 10px;">堆栈</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/04/24/copy/">copy与mutableCopy的内存管理剖析</a>
          </li>
        
          <li>
            <a href="/2016/04/18/Block/">block深度剖析</a>
          </li>
        
          <li>
            <a href="/2016/04/18/TextAndImage/">文字和图片混排</a>
          </li>
        
          <li>
            <a href="/2016/04/18/HeapAndStack/">深度剖析堆栈</a>
          </li>
        
          <li>
            <a href="/2016/04/18/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Xiang<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>